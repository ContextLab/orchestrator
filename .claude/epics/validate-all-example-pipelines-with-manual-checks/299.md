---
id: 001
title: Template Resolution System Fix (GitHub #223 - CRITICAL)
epic: validate-all-example-pipelines-with-manual-checks
created: 2025-08-25T18:40:00Z
updated: 2025-08-29T12:41:55Zgithub: https://github.com/ContextLab/orchestrator/issues/299status: completed
priority: critical
estimated_hours: 16
depends_on: []
parallel: false
week: 1
github_issues: [223]
---

# Template Resolution System Fix (GitHub #223 - CRITICAL)

**⚠️ CRITICAL BLOCKER: This task must be completed first as most pipeline failures stem from template resolution issues.**

## Problem Statement

The template resolution system has fundamental failures that prevent most example pipelines from working correctly:

1. **Template variables unavailable in loop contexts** - Variables defined in loops not accessible to nested templates
2. **Filesystem operations fail to resolve templates** - File paths with `{{variables}}` not resolved before operations
3. **Structured data not exposed properly to templates** - Complex data structures not accessible in template contexts  
4. **Inconsistent template resolution timing** - Templates sometimes resolved after tool execution instead of before

## Root Cause Analysis

Based on GitHub #223 investigation:
- Template resolution happens at compilation time for some contexts but runtime for others
- Loop variable scoping not properly maintained across template resolution boundaries
- Filesystem operations receive unresolved template strings
- Data structures lose context when passed through template resolution chain

## Technical Solution

### 1. Unified Template Resolution Layer
**Create single point of template resolution that handles all contexts**

```python
class UnifiedTemplateResolver:
    def __init__(self):
        self.context_stack = []  # Hierarchical context management
        
    def resolve_templates_before_execution(self, step_config: dict, execution_context: dict) -> dict:
        """Resolve ALL templates BEFORE any tool execution"""
        # 1. Build complete context including loop variables
        full_context = self._build_complete_context(execution_context)
        
        # 2. Resolve all template strings in configuration
        resolved_config = self._resolve_recursively(step_config, full_context)
        
        # 3. Validate no unresolved templates remain
        self._validate_resolution_complete(resolved_config)
        
        return resolved_config
```

### 2. Loop Context Support
**Ensure template variables available in ALL loop contexts**

```python
def _build_complete_context(self, execution_context: dict) -> dict:
    """Build complete template context including all loop variables"""
    context = {}
    
    # 1. Global pipeline context
    context.update(execution_context.get('global_vars', {}))
    
    # 2. Current step context  
    context.update(execution_context.get('step_vars', {}))
    
    # 3. Loop iteration context (CRITICAL FIX)
    for loop_level in execution_context.get('loop_stack', []):
        context.update(loop_level.get('iteration_vars', {}))
        context.update(loop_level.get('loop_vars', {}))
    
    # 4. Structured data exposure
    self._expose_structured_data(context, execution_context)
    
    return context
```

### 3. Filesystem Operation Template Resolution
**Resolve templates in file paths before filesystem operations**

```python
def resolve_filesystem_paths(self, paths: Union[str, List[str]], context: dict) -> Union[str, List[str]]:
    """Resolve template variables in filesystem paths"""
    if isinstance(paths, str):
        return self._resolve_path_template(paths, context)
    return [self._resolve_path_template(path, context) for path in paths]

def _resolve_path_template(self, path: str, context: dict) -> str:
    """Resolve single path template with validation"""
    resolved = self.jinja_env.from_string(path).render(context)
    
    # Validate no unresolved templates
    if '{{' in resolved or '}}' in resolved:
        raise TemplateResolutionError(f"Unresolved template in path: {resolved}")
        
    return resolved
```

### 4. Structured Data Exposure
**Properly expose complex data structures to templates**

```python
def _expose_structured_data(self, context: dict, execution_context: dict):
    """Expose structured data properly to template context"""
    
    # 1. Previous step outputs as structured data
    for step_name, output in execution_context.get('step_outputs', {}).items():
        if isinstance(output, (dict, list)):
            context[f"{step_name}_data"] = output
            
        # 2. Expose individual fields for easy access
        if isinstance(output, dict):
            for key, value in output.items():
                context[f"{step_name}_{key}"] = value
    
    # 3. Loop iteration data structures
    for i, loop_level in enumerate(execution_context.get('loop_stack', [])):
        current_item = loop_level.get('current_item')
        if isinstance(current_item, dict):
            context['item'] = current_item
            context.update(current_item)  # Direct field access
```

## Implementation Tasks

### Phase 1: Core Template Resolution Engine
- [ ] **Unified Template Resolver**: Single resolution point for all templates
- [ ] **Context Stack Management**: Hierarchical context with proper scoping
- [ ] **Recursive Template Resolution**: Handle nested templates and data structures
- [ ] **Resolution Validation**: Ensure no unresolved templates remain

### Phase 2: Loop Context Integration  
- [ ] **Loop Variable Scoping**: Variables accessible across nested contexts
- [ ] **Iteration Data Exposure**: Current item and loop metadata available
- [ ] **Multi-level Loop Support**: Handle nested loops with proper variable isolation
- [ ] **Context Propagation**: Variables flow correctly through loop iterations

### Phase 3: Filesystem Template Resolution
- [ ] **Path Template Resolution**: All file paths resolved before operations
- [ ] **Directory Template Support**: Template variables in directory paths
- [ ] **Validation and Error Handling**: Clear errors for unresolved paths
- [ ] **Integration Testing**: Verify all filesystem operations work with templates

### Phase 4: Data Structure Template Support
- [ ] **Structured Data Exposure**: Complex data structures accessible in templates  
- [ ] **Field-level Access**: Individual fields available as template variables
- [ ] **JSON/YAML Data Integration**: Proper handling of structured configuration
- [ ] **Type Preservation**: Data types maintained through template resolution

## Testing Strategy

### 1. Template Resolution Testing
```python
def test_template_resolution_in_loops():
    """Test template variables work in all loop contexts"""
    pipeline = {
        "steps": {
            "process_files": {
                "foreach": {"var": "file", "in": "files"},
                "filesystem": {
                    "read": "{{file.path}}",  # Must resolve to actual path
                    "save": "output_{{file.name}}.txt"  # Must resolve to specific name
                }
            }
        }
    }
    # Verify no unresolved {{}} templates in execution
```

### 2. Integration Testing with Real Pipelines
- Test with actual failing pipelines from GitHub issues #172-182
- Verify template resolution in complex nested scenarios
- Confirm filesystem operations work with template paths
- Validate structured data access in templates

### 3. Regression Testing
- Ensure existing working pipelines continue to function
- Performance testing - template resolution shouldn't slow execution
- Memory usage validation - context management doesn't leak

## Success Criteria

### Technical Success
- ✅ **Universal Template Resolution**: All templates resolve correctly in ALL contexts
- ✅ **No Unresolved Templates**: Zero `{{variable}}` artifacts in any pipeline output
- ✅ **Loop Variable Access**: Variables accessible in all nested loop scenarios
- ✅ **Filesystem Operations**: All file paths resolve before operations
- ✅ **Structured Data Access**: Complex data available in template contexts

### Pipeline Integration Success
- ✅ **Failing Pipelines Fixed**: Issues #172-182 pipelines now execute successfully
- ✅ **No Regressions**: Existing working pipelines continue to function
- ✅ **Performance Maintained**: No significant execution time increase
- ✅ **Error Clarity**: Clear error messages for template resolution failures

## Integration Points

### Current System Integration
- **Template Manager**: Extend existing TemplateManager class
- **Execution Engine**: Integration with pipeline execution flow
- **Context Management**: Work with existing context propagation
- **Error Handling**: Integrate with existing error reporting

### Dependencies Resolution
- **GitHub #183** (Template Rendering): Build upon completed template infrastructure
- **GitHub #184** (Context Management): Leverage existing context system
- **Existing Test Framework**: Add template resolution tests

## Risk Mitigation

### Technical Risks
1. **Complex Nested Scenarios**: Template resolution in deeply nested contexts
   - **Mitigation**: Comprehensive test suite covering all nesting levels
2. **Performance Impact**: Additional resolution overhead
   - **Mitigation**: Caching and efficient resolution algorithms
3. **Breaking Changes**: Changes affect existing functionality
   - **Mitigation**: Extensive regression testing, backward compatibility

### Implementation Risks
1. **Scope Creep**: Template system touches many components
   - **Mitigation**: Clear interface boundaries, focused changes
2. **Integration Complexity**: Multiple systems need updates
   - **Mitigation**: Phased rollout, isolated testing

## Expected Impact

### Immediate Impact
- **Pipeline Execution Success**: Most failing pipelines will start working
- **Template Cleanliness**: Eliminate unresolved template artifacts
- **Filesystem Operations**: File operations work with dynamic paths
- **Data Access**: Structured data available in all template contexts

### Downstream Impact  
- **Enables Pipeline Validation**: Other tasks can proceed once templates work
- **Quality Improvements**: Better outputs without template artifacts
- **User Experience**: Examples work as intended for learning
- **Development Velocity**: Faster pipeline development with reliable templates

**This is the foundation fix that enables all other work in this epic.**
