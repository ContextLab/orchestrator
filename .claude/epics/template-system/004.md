---
name: Comprehensive Context Management and Template Rendering System
status: active
created: 2025-07-31T12:27:39Z
updated: 2025-08-14T23:19:03Z
github: https://github.com/ContextLab/orchestrator/issues/184
imported: true
labels: bug, enhancement
---

# Comprehensive Context Management and Template Rendering System

**GitHub Issue:** [#184](https://github.com/ContextLab/orchestrator/issues/184)
**Status:** OPEN
**Labels:** bug, enhancement

## Description

# Comprehensive Context Management and Template Rendering System

## Problem Statement

The Orchestrator framework currently has significant issues with template rendering and context management:

### Current Issues:
1. **Template placeholders not rendered**: Variables like `{{input_text}}`, `{{output}}`, `{{topic}}` appear as literal text in outputs
2. **Inconsistent context availability**: Pipeline inputs and parameters are not consistently available across all execution contexts
3. **Multiple conflicting systems**: Different components handle template rendering differently, causing confusion
4. **Loop context issues**: Variables within for_each loops don't have proper access to loop items or parent context
5. **No validation at compile time**: Template syntax errors are only discovered at runtime

### Example Problems:
- In `research_minimal.yaml`: File content shows `# Research Summary: {{topic}}` instead of the actual topic
- In `control_flow_advanced.yaml`: Translation files contain placeholders and wrong content
- Template variables work in some contexts (prompts) but not others (file content)

## Root Cause Analysis

### 1. Fragmented Context Management
- Pipeline inputs are registered with the orchestrator's TemplateManager
- Each task execution creates or reuses a TemplateManager with partial context
- Context is passed through multiple layers, losing information at each step
- No unified system for tracking what context should be available where

### 2. Inconsistent Template Rendering
- Some components render templates immediately
- Others defer rendering to runtime
- File content rendering happens at a different stage than parameter rendering
- No clear ownership of when/where templates should be rendered

### 3. Lack of Context Inheritance
- Loop contexts don't properly inherit parent context
- Task-specific context overwrites rather than extends global context
- No clear hierarchy of context precedence

## Proposed Solution

### A. Unified ContextManager Class
Create a dedicated `ContextManager` class that:
- Maintains a hierarchical context stack (global → pipeline → task → loop)
- Provides clear context inheritance rules
- Offers debug methods to inspect available variables
- Handles context serialization for checkpoints

### B. Centralized Template Rendering
- All template rendering goes through the ContextManager
- Clear distinction between compile-time and runtime rendering
- Consistent error handling and reporting
- Support for debugging unrendered templates

### C. Tool and ControlSystem Integration
- Base `Tool` class gets context management methods
- Base `ControlSystem` class ensures context propagation
- Automatic context injection for all tool executions
- Clear API for accessing and modifying context

### D. Compile-Time Validation
- Validate template syntax when loading YAML
- Check for undefined variables (with warnings)
- Verify template filter usage
- Report all issues before execution starts

## Implementation Plan

### Phase 1: Core Infrastructure
1. Implement `ContextManager` class with hierarchical context
2. Integrate with existing `TemplateManager` 
3. Add context inheritance and merging logic
4. Create comprehensive unit tests

### Phase 2: Integration
1. Update `Tool` base class to use ContextManager
2. Update `ControlSystem` to propagate context properly
3. Modify `Orchestrator` to use new context system
4. Update all tools to use centralized rendering

### Phase 3: Validation and Testing
1. Add compile-time template validation to `YAMLCompiler`
2. Create test pipelines for all template scenarios
3. Add regression tests for current issues
4. Create debugging utilities

### Phase 4: Migration
1. Update all example pipelines
2. Fix any remaining template issues
3. Update documentation
4. Add migration guide for custom tools

## Test Requirements

### Unit Tests
- ContextManager hierarchy and inheritance
- Template rendering in all contexts
- Context serialization/deserialization
- Error handling and edge cases

### Integration Tests
- Full pipeline execution with templates
- Loop context inheritance
- Conditional template rendering
- Multi-level nested templates

### Regression Tests
- `research_minimal.yaml` - topic in file content
- `control_flow_advanced.yaml` - loop variables and conditionals
- All 31 example pipelines render correctly

## Success Criteria
1. All template placeholders render correctly in all contexts
2. Clear error messages for undefined variables
3. Consistent behavior across all tools and control systems
4. No regression in existing functionality
5. Improved debuggability of template issues

## Related Issues
- #183 - Template rendering issues across pipelines
- #158-#182 - Individual pipeline validation issues

## Next Steps
1. Review and refine this design
2. Create detailed implementation tasks
3. Begin with ContextManager implementation
4. Incrementally migrate components