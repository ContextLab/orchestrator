name: "Code Analysis Suite"
description: "Comprehensive code analysis with security scanning, quality checks, and AI-powered review"

inputs:
  repo_path:
    type: string
    description: "Path to repository to analyze"
    required: true
  
  languages:
    type: list
    description: "Programming languages to analyze"
    default: ["python", "javascript", "typescript"]
  
  analysis_depth:
    type: string
    description: "Analysis depth (quick, standard, comprehensive)"
    default: "comprehensive"
  
  security_scan:
    type: boolean
    description: "Enable security vulnerability scanning"
    default: true
  
  performance_check:
    type: boolean
    description: "Enable performance profiling"
    default: true
  
  doc_check:
    type: boolean
    description: "Check documentation coverage"
    default: true
  
  severity_threshold:
    type: string
    description: "Minimum severity to report (low, medium, high, critical)"
    default: "medium"

steps:

  # Step 1: Discover code files
  - id: discover_code
    action: |
      discover all code files in {{repo_path}}:
      1. Find files matching patterns for languages: {{languages}}
      2. Exclude directories: .git, node_modules, venv, __pycache__, dist, build
      3. Count lines of code per file
      4. Identify test files vs source files
      5. Find documentation files (README, docs/)
      Return file list with metadata and statistics
    timeout: 15.0
    
    tags: ["discovery", "filesystem"]

  # Step 2: Static code analysis
  - id: static_analysis
    action: |
      perform static analysis on each code file:
      1. Syntax validation
      2. Linting (style violations)
      3. Type checking where applicable
      4. Cyclomatic complexity calculation
      5. Code duplication detection
      6. Dead code identification
      Return issues categorized by severity and type
      1. Check for hardcoded secrets/credentials
      2. Identify SQL injection risks
      3. Find XSS vulnerabilities
      4. Detect insecure dependencies
      5. Check for command injection risks
      6. Identify authentication/authorization issues
      7. License compliance check
    depends_on: [discover_code]
    condition: "{{security_scan}} == true"
    timeout: 45.0
    tags: ["security", "vulnerabilities"]

  # Step 4: AI-powered code review
  - id: ai_code_review
    action: |
      review code quality using AI analysis for {{loop_item.path}}:
      1. Code structure and organization
      2. Design patterns and best practices
      3. Variable/function naming conventions
      4. Error handling completeness
      5. Performance optimization opportunities
      6. Maintainability assessment
      7. Suggested refactoring improvements
      Provide specific, actionable suggestions
      1. Check for missing function/class docstrings
      2. Verify README completeness
      3. Analyze inline comment quality
      4. Check for API documentation
      5. Verify example code in docs
      6. Calculate documentation coverage percentage
    depends_on: [discover_code]
    condition: "{{doc_check}} == true"
    tags: ["documentation", "coverage"]

  # Step 6: Performance profiling
  - id: performance_analysis
    action: |
      profile code for performance issues:
      1. Identify computational hotspots
      2. Find inefficient algorithms (O(nÂ²) or worse)
      3. Detect memory leaks or excessive allocation
      4. Check for blocking I/O operations
      5. Identify inefficient database queries
      6. Find unnecessary loops or recursion
      Return performance bottlenecks with optimization suggestions
    depends_on: [static_analysis]
    
    condition: "{{performance_check}} == true"
    timeout: 30.0
    tags: ["performance", "optimization"]

  # Step 7: Dependency analysis
  - id: dependency_check
    action: |
      analyze project dependencies:
      1. Check for outdated dependencies
      2. Identify security vulnerabilities in dependencies
      3. Detect unused dependencies
      4. Check for dependency conflicts
      5. Analyze dependency tree depth
      6. Suggest dependency updates
      Return dependency health report
    depends_on: [discover_code]
    
    tags: ["dependencies", "maintenance"]

  # Step 8: Test coverage analysis
  - id: test_coverage
    action: |
      analyze test coverage:
      1. Identify untested code paths
      2. Calculate line/branch coverage
      3. Find missing test cases
      4. Analyze test quality and assertions
      5. Check for test duplication
      6. Suggest additional test scenarios
      Return coverage metrics and recommendations
    depends_on: [discover_code]
    
    condition: "{{discover_code.result.test_files_count}} > 0"
    tags: ["testing", "coverage"]

  # Step 9: Architecture analysis
  - id: architecture_review
    action: |
      analyze code architecture:
      1. Identify architectural patterns used
      2. Check for circular dependencies
      3. Analyze module coupling and cohesion
      4. Review layer separation
      5. Check for SOLID principle violations
      6. Identify potential design improvements
      Return architecture assessment and recommendations
    depends_on: [static_analysis, ai_code_review]
    
    condition: "{{analysis_depth}} == 'comprehensive'"
    tags: ["architecture", "design"]

  # Step 10: Generate actionable insights
  - id: generate_insights
    action: |
      synthesize all findings into actionable insights:
      1. Prioritize issues by impact and effort
      2. Group related issues together
      3. Create fix order recommendation
      4. Estimate time to fix each issue
      5. Identify quick wins vs long-term improvements
      6. Generate team-specific recommendations
      Return prioritized action plan
    depends_on: [static_analysis, ai_code_review, performance_analysis]
    
    tags: ["insights", "recommendations"]

  # Step 11: Generate comprehensive report
  - id: generate_report
    action: |
      create detailed analysis report including:
      1. Executive summary with key metrics
      2. Quality score (0-100) with breakdown
      3. Security score with critical issues highlighted
      4. Top 10 priority issues to fix
      5. Code metrics dashboard (complexity, duplication, etc.)
      6. Trend analysis if historical data available
      7. Team performance insights
      8. Detailed findings by category
      Format as markdown report with charts/visualizations
    depends_on: [generate_insights, test_coverage, architecture_review]
    
    on_error:
      action: |
        generate basic report with available data
        continue_on_error: true
      timeout: 30.0
    tags: ["reporting", "output"]

  # Step 12: Generate CI/CD artifacts
  - id: generate_artifacts
    action: |
      create CI/CD integration artifacts:
      1. JSON report for CI tools
      2. Badge data for README (quality, coverage, security)
      3. PR comment summary
      4. SARIF file for GitHub security tab
      5. SonarQube compatible report
      Return artifact paths and integration instructions
    depends_on: [generate_report]
    
    tags: ["ci-cd", "integration"]

  - id: save_output
    action: |
      Save the following content to examples/output/code_analysis_suite.md:
      # Code Analysis Suite
      *Generated on: {{execution.timestamp}}*
      *Pipeline: code_analysis_suite*
      ## Results
      {% for step_id, result in results.items() if step_id != 'save_output' %}
      ### {{ step_id }}
      {{ result | truncate(1000) }}
      {% endfor %}
      ---
      *Generated by Orchestrator Pipeline*
    depends_on: ["generate_artifacts"]

outputs:
  quality_score: "{{generate_report.result.quality_score}}"
  security_score: "{{generate_report.result.security_score}}"
  documentation_score: "{{documentation_check.result.coverage_percentage}}"
  test_coverage: "{{test_coverage.result.coverage_percentage}}"
  total_issues: "{{generate_report.result.total_issues}}"
  critical_issues: "{{generate_report.result.critical_issues}}"
  files_analyzed: "{{discover_code.result.total_files}}"
  lines_of_code: "{{discover_code.result.total_lines}}"
  report_path: "{{generate_report.result.report_path}}"
  action_items: "{{generate_insights.result.action_items}}"
  estimated_fix_time: "{{generate_insights.result.total_fix_time}}"
  ci_artifacts: "{{generate_artifacts.result.artifacts}}"