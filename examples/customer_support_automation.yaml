name: "Customer Support Automation"
description: "AI-powered customer support with ticket management, automated responses, and intelligent routing"

inputs:
  ticket_id:
    type: string
    description: "Support ticket ID to process"
    required: true
  
  ticketing_system:
    type: string
    description: "Ticketing system (zendesk, freshdesk, jira)"
    default: "zendesk"
  
  auto_respond:
    type: boolean
    description: "Enable automated responses"
    default: true
  
  languages:
    type: list
    description: "Supported languages for multi-language support"
    default: ["en", "es", "fr"]
  
  escalation_threshold:
    type: float
    description: "Sentiment threshold for escalation (-1 to 1)"
    default: -0.5
  
  kb_confidence_threshold:
    type: float
    description: "Knowledge base confidence threshold for auto-response"
    default: 0.75

steps:

  - id: save_output
    action: |
      Save the following content to examples/output/customer_support_automation.md:
      
      # Customer Support Automation
      
      *Generated on: {{execution.timestamp}}*
      *Pipeline: customer_support_automation*
      
      ## Results
      
      {% for step_id, result in results.items() if step_id != 'save_output' %}
      ### {{ step_id }}
      
      {{ result | truncate(1000) }}
      
      {% endfor %}
      
      ---
      *Generated by Orchestrator Pipeline*
    depends_on: ["{{ previous_steps | join(', ') }}"]

  # Step 1: Fetch ticket details
  - id: receive_ticket
    action: |
      fetch support ticket {{ticket_id}} from {{ticketing_system}}:
      1. Get ticket subject and description
      2. Retrieve customer information and history
      3. Get conversation history
      4. Check customer tier/priority status
      5. Get any attachments or screenshots
      Return complete ticket data and context
    timeout: 10.0
    
    tags: ["ticket", "fetch"]

  # Step 2: Detect language
  - id: detect_language
    action: |
      detect the language of ticket:
      Text: {{receive_ticket.result.description}}
      Supported languages: {{languages}}
      Return detected language with confidence score
    depends_on: [receive_ticket]
    
    tags: ["language", "detection"]

  # Step 3: Analyze customer sentiment
  - id: analyze_sentiment
    action: |
      analyze customer sentiment and emotion:
      Current message: {{receive_ticket.result.description}}
      Conversation history: {{receive_ticket.result.conversation_history}}
      Detect:
      1. Overall sentiment score (-1 to 1)
      2. Specific emotions (anger, frustration, satisfaction)
      3. Urgency level
      4. Customer frustration indicators
      5. Potential churn risk
      Return sentiment analysis with scores
    depends_on: [receive_ticket]
    
    timeout: 15.0
    tags: ["sentiment", "analysis"]

  # Step 4: Extract key information
  - id: extract_entities
    action: |
      extract key information from ticket:
      1. Product names or SKUs mentioned
      2. Order numbers or transaction IDs
      3. Account identifiers
      4. Error messages or codes
      5. Dates and timeframes
      6. Technical specifications
      Return extracted entities with confidence
    depends_on: [receive_ticket]
    
    tags: ["extraction", "entities"]

  # Step 5: Classify ticket
  - id: classify_ticket
    action: |
      classify the support ticket:
      Title: {{receive_ticket.result.subject}}
      Description: {{receive_ticket.result.description}}
      Extracted entities: {{extract_entities.result}}
      Determine:
      1. Primary category (billing, technical, account, etc.)
      2. Secondary categories
      3. Relevant tags
      4. Priority score (0-10)
      5. Complexity level
      Return classification with confidence scores
    depends_on: [extract_entities]
    cache_results: true
    tags: ["classification", "categorization"]

  # Step 6: Search knowledge base
  - id: search_knowledge_base
    action: |
      search knowledge base for solutions:
      Query: {{receive_ticket.result.description}}
      Category: {{classify_ticket.result.primary_category}}
      Customer context: {{receive_ticket.result.customer_info}}
      Find:
      1. Relevant help articles
      2. Similar resolved tickets
      3. Step-by-step solutions
      4. Video tutorials if available
      5. Internal knowledge base entries
      Return top 5 matches with relevance scores
    depends_on: [classify_ticket]
    
    timeout: 20.0
    tags: ["knowledge-base", "search"]

  # Step 7: Check automation eligibility
  - id: check_automation_eligibility
    action: |
      determine if ticket can be automated:
      Category: {{classify_ticket.result.primary_category}}
      Sentiment score: {{analyze_sentiment.result.sentiment_score}}
      KB confidence: {{search_knowledge_base.result.confidence_score}}
      Customer tier: {{receive_ticket.result.customer_info.tier}}
      Previous escalations: {{receive_ticket.result.customer_info.escalation_count}}
      Check:
      1. Is category automatable?
      2. Is sentiment above threshold ({{escalation_threshold}})?
      3. Is KB confidence above {{kb_confidence_threshold}}?
      4. Is customer tier eligible for automation?
      5. Any red flags requiring human review?
      Return automation decision with reasoning
    depends_on: [search_knowledge_base, analyze_sentiment]
    
    tags: ["automation", "eligibility"]

  # Step 8: Generate automated response
  - id: generate_response
    action: |
      generate personalized support response:
      Ticket content: {{receive_ticket.result}}
      KB articles: {{search_knowledge_base.result.articles}}
      Customer name: {{receive_ticket.result.customer_info.name}}
      Language: {{detect_language.result.language}}
      Create response that:
      1. Acknowledges the specific issue
      2. Shows empathy matching customer sentiment
      3. Provides clear solution steps
      4. Includes relevant KB article links
      5. Sets expectations for resolution
      6. Offers additional help if needed
      Tone:
      Match customer formality and urgency
      Return response text with solution steps
    depends_on: [check_automation_eligibility]
    
    condition: "{{check_automation_eligibility.result.can_automate}} == true and {{auto_respond}} == true"
    timeout: 30.0
    tags: ["response", "generation"]

  # Step 9: Translate response if needed
  - id: translate_response
    action: |
      translate response to customer's language:
      Text: {{generate_response.result.response_text}}
      Target language: {{detect_language.result.language}}
      Maintain:
      1. Professional tone
      2. Technical accuracy
      3. Cultural appropriateness
      4. Format and structure
      Return translated text
    depends_on: [generate_response]
    
    condition: "{{detect_language.result.language}} != 'en'"
    tags: ["translation", "localization"]

  # Step 10: Update ticket in system
  - id: update_ticket
    action: |
      update ticket in {{ticketing_system}}:
      Ticket ID: {{ticket_id}}
      Updates:
      - Category: {{classify_ticket.result.primary_category}}
      - Tags: {{classify_ticket.result.tags}}
      - Priority: {{classify_ticket.result.priority_score}}
      - Language: {{detect_language.result.language}}
      - Sentiment: {{analyze_sentiment.result.sentiment_score}}
      - Status: {{'pending' if check_automation_eligibility.result.can_automate else 'open'}}
      Return update confirmation
    depends_on: [classify_ticket]
    
    tags: ["update", "ticket"]

  # Step 11: Send automated response
  - id: send_response
    action: |
      send response to customer via {{ticketing_system}}:
      Ticket ID: {{ticket_id}}
      Response: {{translate_response.result | default(generate_response.result.response_text)}}
      Include:
      1. Response text
      2. Solution steps if applicable
      3. KB article links
      4. Expected resolution time
      Mark as public response
      Close ticket if issue fully resolved
      Return response confirmation
    depends_on: [generate_response, update_ticket]
    
    condition: "{{generate_response.result}} != null"
    tags: ["send", "response"]

  # Step 12: Assign to human agent
  - id: assign_to_agent
    action: |
      assign ticket to appropriate human agent:
      Category: {{classify_ticket.result.primary_category}}
      Priority: {{classify_ticket.result.priority_score}}
      Required skills: {{classify_ticket.result.required_expertise}}
      Customer tier: {{receive_ticket.result.customer_info.tier}}
      Language: {{detect_language.result.language}}
      Find best available agent based on:
      1. Skill match
      2. Current workload
      3. Language capability
      4. Customer history
      5. Availability status
      Create handoff package with:
      - Classification results
      - Sentiment analysis
      - KB search results
      - Customer context
      - Suggested approach
      Return assigned agent details
    depends_on: [check_automation_eligibility, update_ticket]
    
    condition: "{{check_automation_eligibility.result.can_automate}} == false"
    tags: ["escalation", "assignment"]

  # Step 13: Monitor SLA compliance
  - id: monitor_sla
    action: |
      check SLA compliance for ticket:
      Ticket created: {{receive_ticket.result.created_at}}
      Customer tier: {{receive_ticket.result.customer_info.tier}}
      Priority: {{classify_ticket.result.priority_score}}
      Check against SLA policies:
      1. First response time
      2. Resolution time
      3. Update frequency
      Calculate:
      - Current SLA status
      - Time remaining to next milestone
      - Risk of breach
      Return SLA monitoring results
    depends_on: [update_ticket]
    
    tags: ["sla", "monitoring"]

  # Step 14: Create follow-up tasks
  - id: create_followup
    action: |
      create follow-up tasks if needed:
      Based on ticket analysis:
      1. Schedule satisfaction survey
      2. Set reminder for resolution check
      3. Flag for quality review if automated
      4. Create escalation task if SLA at risk
      5. Schedule proactive check-in for VIP customers
      Return created tasks
    depends_on: [send_response, assign_to_agent, monitor_sla]
    
    condition: "{{generate_response.result.follow_up_needed}} == true or {{monitor_sla.result.at_risk}} == true"
    tags: ["followup", "tasks"]

  # Step 15: Log analytics
  - id: log_analytics
    action: |
      log support interaction analytics:
      Ticket ID: {{ticket_id}}
      Automation status: {{'automated' if check_automation_eligibility.result.can_automate else 'manual'}}
      Category: {{classify_ticket.result.primary_category}}
      Sentiment: {{analyze_sentiment.result}}
      KB effectiveness: {{search_knowledge_base.result.solution_found}}
      Response time:
      Calculate from timestamps
      Customer tier: {{receive_ticket.result.customer_info.tier}}
      Language: {{detect_language.result.language}}
      Track metrics for reporting and optimization
    depends_on: [send_response, assign_to_agent]
    
    tags: ["analytics", "logging"]

outputs:
  ticket_id: "{{ticket_id}}"
  automation_status: "{{'automated' if check_automation_eligibility.result.can_automate else 'escalated'}}"
  assigned_agent: "{{assign_to_agent.result.agent_name}}"
  response_sent: "{{send_response.result.success}}"
  category: "{{classify_ticket.result.primary_category}}"
  priority: "{{classify_ticket.result.priority_score}}"
  sentiment_score: "{{analyze_sentiment.result.sentiment_score}}"
  language: "{{detect_language.result.language}}"
  sla_status: "{{monitor_sla.result.status}}"
  kb_helpful: "{{search_knowledge_base.result.solution_found}}"
  response_time_seconds: "{{log_analytics.result.response_time}}"
  follow_up_scheduled: "{{create_followup.result.tasks_created}}"