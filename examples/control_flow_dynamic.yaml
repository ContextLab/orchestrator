id: control-flow-dynamic
# Dynamic Flow Control Example
# Demonstrates goto and dynamic dependencies with AUTO resolution
name: Error Handling Pipeline
description: Dynamic flow control based on error conditions
version: "1.0.0"

parameters:
  operation:
    type: string
    description: Operation to perform
    default: "echo 'Hello, World!'"
  retry_limit:
    type: integer
    default: 3

steps:
  # Initial validation
  - id: validate_input
    action: generate_text
    parameters:
      prompt: |
        Validate if this is a safe operation to execute: "{{ operation }}"
        Return only "valid" if safe, or "invalid" if unsafe.
      model: <AUTO task="validate">Select a model for validation</AUTO>
      max_tokens: 10
      
  # Determine operation risk level
  - id: assess_risk
    action: generate_text
    parameters:
      prompt: |
        Assess the risk level of this operation: "{{ operation }}"
        Return ONLY one word: low, medium, or high
      model: <AUTO task="assess">Select a model for risk assessment</AUTO>
      max_tokens: 10
    dependencies:
      - validate_input
    
  # Prepare operation
  - id: prepare_operation
    action: generate_text
    parameters:
      prompt: |
        Prepare to execute operation: {{ operation }}
        Risk level: {{ assess_risk }}
        Return "ready" if prepared.
      model: <AUTO task="prepare">Select a model</AUTO>
      max_tokens: 50
    dependencies:
      - validate_input
      - assess_risk
    
  # Optional safety check for high-risk operations
  - id: safety_check
    action: generate_text
    condition: "{{ assess_risk == 'high' }}"
    parameters:
      prompt: |
        Perform additional safety check for high-risk operation: {{ operation }}
        Return "safe" or "unsafe"
      model: <AUTO task="safety">Select a model</AUTO>
      max_tokens: 10
    dependencies:
      - assess_risk
    
  # Execute operation (REAL execution)
  - id: execute_operation
    tool: terminal
    action: execute
    parameters:
      command: "{{ operation }}"
    dependencies:
      - prepare_operation
    
  # Check execution result
  - id: check_result
    action: generate_text
    parameters:
      prompt: |
        Analyze this execution output: {{ execute_operation }}
        
        Return EXACTLY one word - either "success" or "failure".
        Do not add any explanation or other text.
      model: <AUTO task="check">Select a model</AUTO>
      max_tokens: 10
    dependencies:
      - execute_operation
    
  # Generate success report
  - id: success_handler
    action: generate_text
    condition: "{{ check_result == 'success' }}"
    parameters:
      prompt: |
        Write a brief success summary. NO placeholders, NO conversational language.
        
        Operation: {{ operation }}
        Risk Level: {{ assess_risk }}
        Status: SUCCESS
        
        Format as a simple bulleted list with these exact items:
        - Operation executed successfully
        - Risk level: {{ assess_risk }}
        - Command completed without errors
      model: <AUTO task="report">Select a model</AUTO>
      max_tokens: 150
    dependencies:
      - check_result
    
  # Generate failure report
  - id: failure_handler
    action: generate_text
    condition: "{{ check_result == 'failure' }}"
    parameters:
      prompt: |
        Write a brief failure summary. NO placeholders, NO conversational language.
        
        Operation: {{ operation }}
        Risk Level: {{ assess_risk }}
        Status: FAILED
        Error: Execution did not complete successfully
        
        Format as a simple bulleted list.
      model: <AUTO task="report">Select a model</AUTO>
      max_tokens: 150
    dependencies:
      - check_result
    
  # Cleanup
  - id: cleanup
    action: generate_text
    parameters:
      prompt: |
        Return EXACTLY the word "cleaned" - nothing else.
      model: <AUTO task="cleanup">Select a model</AUTO>
      max_tokens: 10
    dependencies:
      - success_handler
      - failure_handler
      
  # Save final report
  - id: save_report
    tool: filesystem
    action: write
    parameters:
      path: "examples/outputs/control_flow_dynamic/report_{{ operation | slugify }}.md"
      content: |
        # Dynamic Flow Control Execution Report
        
        **Operation:** {{ operation }}
        **Risk Level:** {{ assess_risk }}
        
        ## Execution Summary
        
        - Validation: {{ validate_input }}
        - Preparation: {{ prepare_operation }}
        - Execution Result: {{ check_result }}
        
        ## Command Execution Details
        
        - **Command:** {{ execute_operation.command }}
        - **Return Code:** {{ execute_operation.return_code }}
        - **Success:** {{ execute_operation.success }}
        - **Execution Time:** {{ execute_operation.execution_time }}ms
        
        ### Command Output (stdout):
        ```
        {{ execute_operation.stdout }}
        ```
        
        {% if execute_operation.stderr %}
        ### Command Errors (stderr):
        ```
        {{ execute_operation.stderr }}
        ```
        {% endif %}
        
        ## Report Details
        
        {% if check_result == 'success' %}
        {{ success_handler }}
        {% else %}
        {{ failure_handler }}
        {% endif %}
        
        ## Cleanup Status
        
        {{ cleanup }}
        
        ---
        *Generated by Dynamic Flow Control Pipeline*
    dependencies:
      - cleanup

outputs:
  validation_result: "{{ validate_input }}"
  risk_level: "{{ assess_risk }}"
  execution_status: "{{ check_result }}"
  final_report: "{{ save_report.path }}"