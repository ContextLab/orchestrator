# Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder # Code Optimization Report

**File:** {{code_file}}
**Language:** python
**Date:** 2025-08-28 00:07:40

## Analysis Results

I don’t see any Python code in your message—the placeholder {{content}} is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions is empty. Please paste the code between triple backticks so I can analyze it.

If you’d like me to tailor the review, also share:
- Python version and runtime (CPython/PyPy), OS
- Typical input sizes and performance goals
- Allowed third‑party libraries
- Whether it’s CPU-, I/O-, or memory-bound

What I will deliver
1) Performance bottlenecks
- Algorithmic complexity (e.g., nested loops, N^2 joins/merges, repeated sorting)
- Inefficient data structures (lists vs sets/dicts; string concatenation in loops)
- Redundant work (recomputations, repeated I/O, repeated regex compilation)
- Non-vectorized numeric/dataframe operations; Python loops over arrays
- Inefficient I/O (small reads/writes, no buffering, synchronous network calls)
- Unbounded growth (caches, lists) and unnecessary copies
- Serialization hot paths (pickle/json) and slow logging in hot loops
- GIL-bound CPU work without native extensions; missed concurrency opportunities

2) Code quality issues
- Long or deeply nested functions; cyclomatic complexity
- Duplicated code; poor separation of concerns
- Weak naming, missing docstrings/comments, unclear invariants
- Fragile error handling (bare except, swallowing exceptions)
- Lack of tests or untested branches; missing input validation
- Inconsistent typing hints; misuse of mutability and default args
- Resource management issues (missing context managers, leaks)

3) Best practice violations
- Mutable default arguments; global state misuse
- Blocking calls in async code; mixing sync/async improperly
- Hard-coded constants/paths; magic numbers
- Insecure patterns (eval/exec, unsafe pickle, subprocess shell=True)
- Inefficient imports or side effects at import time
- No logging or excessive logging at INFO in hot paths
- Not using pathlib, f-strings, contextlib, functools.lru_cache where appropriate
- Not pinning dependencies; missing lint/format (ruff/flake8, black), CI

If you prefer, share a gist/repo link, and I can run a focused review.

## Optimization Summary

The optimized code has been saved to: examples/outputs/code_optimization/optimized_{{code_file}}

## Original vs Optimized

### Original Code Issues Identified:
See analysis above for detailed breakdown.

### Optimized Code Benefits:
- Improved performance through algorithmic optimizations
- Enhanced code quality and maintainability
- Better error handling and validation
- Adherence to best practices and conventions