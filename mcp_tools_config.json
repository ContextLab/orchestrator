{
  "tools": [
    {
      "name": "headless-browser",
      "description": "Perform web browsing, search, and verification tasks using a headless browser",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "Action to perform: 'search', 'verify', 'scrape', 'scrape_js'"
          },
          "url": {
            "type": "string",
            "description": "URL to visit (for verify/scrape)"
          },
          "query": {
            "type": "string",
            "description": "Search query (for search)"
          },
          "sources": {
            "type": "array",
            "description": "List of sources to search"
          },
          "max_results": {
            "type": "integer",
            "description": "Maximum number of search results"
          },
          "backend": {
            "type": "string",
            "description": "Search backend to use (duckduckgo, bing, google)"
          }
        },
        "required": [
          "action"
        ]
      }
    },
    {
      "name": "web-search",
      "description": "Perform web search and return results",
      "inputSchema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "Search query"
          },
          "max_results": {
            "type": "integer",
            "description": "Maximum number of results"
          },
          "backend": {
            "type": "string",
            "description": "Search backend to use (duckduckgo, bing, google)"
          }
        },
        "required": [
          "query"
        ]
      }
    },
    {
      "name": "terminal",
      "description": "Execute terminal commands in a sandboxed environment",
      "inputSchema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "description": "Command to execute"
          },
          "working_dir": {
            "type": "string",
            "description": "Working directory"
          },
          "timeout": {
            "type": "integer",
            "description": "Timeout in seconds"
          },
          "capture_output": {
            "type": "boolean",
            "description": "Capture command output"
          }
        },
        "required": [
          "command"
        ]
      }
    },
    {
      "name": "filesystem",
      "description": "Perform file system operations like read, write, copy, move",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "Action: 'read', 'write', 'copy', 'move', 'delete', 'list'"
          },
          "path": {
            "type": "string",
            "description": "File or directory path"
          },
          "content": {
            "type": "string",
            "description": "Content to write (for write action)"
          },
          "destination": {
            "type": "string",
            "description": "Destination path (for copy/move)"
          }
        },
        "required": [
          "action",
          "path"
        ]
      }
    },
    {
      "name": "data-processing",
      "description": "Process and transform data in various formats",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "Action: 'convert', 'filter', 'aggregate', 'transform'"
          },
          "data": {
            "type": "object",
            "description": "Input data or file path"
          },
          "format": {
            "type": "string",
            "description": "Data format: 'json', 'csv', 'yaml'"
          },
          "operation": {
            "type": "object",
            "description": "Operation details"
          }
        },
        "required": [
          "action",
          "data"
        ]
      }
    },
    {
      "name": "report-generator",
      "description": "Generate structured markdown reports from research data",
      "inputSchema": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "Report title"
          },
          "query": {
            "type": "string",
            "description": "Research query"
          },
          "context": {
            "type": "string",
            "description": "Research context"
          },
          "search_results": {
            "type": "object",
            "description": "Search results data"
          },
          "extraction_results": {
            "type": "object",
            "description": "Content extraction data"
          },
          "findings": {
            "type": "array",
            "description": "Key findings"
          },
          "recommendations": {
            "type": "array",
            "description": "Recommendations"
          },
          "quality_score": {
            "type": "number",
            "description": "Quality score"
          }
        },
        "required": [
          "title",
          "query",
          "search_results",
          "extraction_results"
        ]
      }
    },
    {
      "name": "pdf-compiler",
      "description": "Compile markdown reports to PDF using pandoc",
      "inputSchema": {
        "type": "object",
        "properties": {
          "markdown_content": {
            "type": "string",
            "description": "Markdown content to compile"
          },
          "output_path": {
            "type": "string",
            "description": "Output PDF file path"
          },
          "title": {
            "type": "string",
            "description": "Document title"
          },
          "author": {
            "type": "string",
            "description": "Document author"
          },
          "install_if_missing": {
            "type": "boolean",
            "description": "Install pandoc if not found"
          }
        },
        "required": [
          "markdown_content",
          "output_path"
        ]
      }
    },
    {
      "name": "task-delegation",
      "description": "Analyze task requirements and select the best model for execution",
      "inputSchema": {
        "type": "object",
        "properties": {
          "task": {
            "type": "string",
            "description": "The task to be executed"
          },
          "requirements": {
            "type": "object",
            "description": "Task requirements and constraints"
          },
          "fallback_enabled": {
            "type": "boolean",
            "description": "Enable fallback to alternative models"
          },
          "cost_weight": {
            "type": "number",
            "description": "Weight for cost optimization (0-1)"
          },
          "quality_weight": {
            "type": "number",
            "description": "Weight for quality optimization (0-1)"
          }
        },
        "required": [
          "task",
          "fallback_enabled",
          "cost_weight",
          "quality_weight"
        ]
      }
    },
    {
      "name": "multi-model-routing",
      "description": "Route requests across multiple models with load balancing and cost optimization",
      "inputSchema": {
        "type": "object",
        "properties": {
          "request": {
            "type": "string",
            "description": "The request to route"
          },
          "models": {
            "type": "array",
            "description": "List of models to route between"
          },
          "strategy": {
            "type": "string",
            "description": "Routing strategy: round_robin, least_loaded, cost_optimized, capability_based"
          },
          "max_concurrent": {
            "type": "integer",
            "description": "Maximum concurrent requests per model"
          },
          "timeout": {
            "type": "number",
            "description": "Request timeout in seconds"
          }
        },
        "required": [
          "request",
          "strategy",
          "max_concurrent",
          "timeout"
        ]
      }
    },
    {
      "name": "prompt-optimization",
      "description": "Optimize prompts for specific models, including formatting and token management",
      "inputSchema": {
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "The prompt to optimize"
          },
          "model": {
            "type": "string",
            "description": "Target model for optimization"
          },
          "optimization_goals": {
            "type": "array",
            "description": "Goals: clarity, brevity, specificity, model_specific"
          },
          "max_tokens": {
            "type": "integer",
            "description": "Maximum token limit"
          },
          "preserve_intent": {
            "type": "boolean",
            "description": "Preserve original intent"
          }
        },
        "required": [
          "prompt",
          "optimization_goals",
          "preserve_intent"
        ]
      }
    },
    {
      "name": "user-prompt",
      "description": "Prompt users for input with support for defaults and timeouts",
      "inputSchema": {
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "The prompt to display to the user"
          },
          "input_type": {
            "type": "string",
            "description": "Type of input: text, number, boolean, choice"
          },
          "default": {
            "type": "any",
            "description": "Default value if no input provided"
          },
          "choices": {
            "type": "array",
            "description": "Available choices for 'choice' input type"
          },
          "timeout": {
            "type": "number",
            "description": "Timeout in seconds (0 for no timeout)"
          },
          "context": {
            "type": "string",
            "description": "Execution context: cli, gui, api"
          },
          "validation_pattern": {
            "type": "string",
            "description": "Regex pattern for input validation"
          },
          "retry_on_invalid": {
            "type": "boolean",
            "description": "Retry if validation fails"
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum validation retries"
          }
        },
        "required": [
          "prompt",
          "input_type",
          "timeout",
          "context",
          "retry_on_invalid",
          "max_retries"
        ]
      }
    },
    {
      "name": "approval-gate",
      "description": "Present results for user review and approval",
      "inputSchema": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "Title of the approval request"
          },
          "content": {
            "type": "string",
            "description": "Content to review"
          },
          "format": {
            "type": "string",
            "description": "Content format: text, json, markdown"
          },
          "allow_modifications": {
            "type": "boolean",
            "description": "Allow user to modify content"
          },
          "require_reason": {
            "type": "boolean",
            "description": "Require reason for rejection"
          },
          "context": {
            "type": "string",
            "description": "Execution context: cli, gui, api"
          },
          "auto_approve_hash": {
            "type": "string",
            "description": "Auto-approve if content hash matches"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata for the approval"
          }
        },
        "required": [
          "title",
          "content",
          "format",
          "allow_modifications",
          "require_reason",
          "context"
        ]
      }
    },
    {
      "name": "feedback-collection",
      "description": "Collect structured feedback with various question types",
      "inputSchema": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "Feedback form title"
          },
          "questions": {
            "type": "array",
            "description": "List of feedback questions"
          },
          "anonymous": {
            "type": "boolean",
            "description": "Allow anonymous feedback"
          },
          "required_questions": {
            "type": "array",
            "description": "IDs of required questions"
          },
          "context": {
            "type": "string",
            "description": "Execution context: cli, gui, api"
          },
          "save_to_file": {
            "type": "string",
            "description": "File path to save feedback"
          }
        },
        "required": [
          "title",
          "questions",
          "anonymous",
          "required_questions",
          "context"
        ]
      }
    },
    {
      "name": "pipeline-executor",
      "description": "Execute a sub-pipeline as part of a larger workflow",
      "inputSchema": {
        "type": "object",
        "properties": {
          "pipeline": {
            "type": "string",
            "description": "Pipeline definition (YAML path, ID, or inline YAML)"
          },
          "inputs": {
            "type": "object",
            "description": "Input parameters for the pipeline"
          },
          "inherit_context": {
            "type": "boolean",
            "description": "Inherit context from parent pipeline"
          },
          "wait_for_completion": {
            "type": "boolean",
            "description": "Wait for pipeline to complete"
          },
          "timeout": {
            "type": "number",
            "description": "Execution timeout in seconds (0 for no timeout)"
          },
          "output_mapping": {
            "type": "object",
            "description": "Map pipeline outputs to parent context"
          },
          "error_handling": {
            "type": "string",
            "description": "Error handling: fail, continue, retry"
          },
          "retry_count": {
            "type": "integer",
            "description": "Number of retries on failure"
          },
          "retry_delay": {
            "type": "number",
            "description": "Delay between retries in seconds"
          }
        },
        "required": [
          "pipeline",
          "inputs",
          "inherit_context",
          "wait_for_completion",
          "timeout",
          "output_mapping",
          "error_handling",
          "retry_count",
          "retry_delay"
        ]
      }
    },
    {
      "name": "recursion-control",
      "description": "Control recursive pipeline execution with conditions and limits",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "Action: check_condition, update_state, get_state, reset"
          },
          "condition": {
            "type": "string",
            "description": "Termination condition expression"
          },
          "state_key": {
            "type": "string",
            "description": "Key for state value"
          },
          "state_value": {
            "type": "any",
            "description": "Value to set for state"
          },
          "increment": {
            "type": "number",
            "description": "Increment state value by amount"
          },
          "max_iterations": {
            "type": "integer",
            "description": "Maximum iterations allowed"
          },
          "depth_limit": {
            "type": "integer",
            "description": "Maximum recursion depth"
          },
          "time_limit": {
            "type": "number",
            "description": "Time limit in seconds"
          }
        },
        "required": [
          "action",
          "max_iterations",
          "depth_limit",
          "time_limit"
        ]
      }
    },
    {
      "name": "image-analysis",
      "description": "Analyze images for content, objects, text, and more",
      "inputSchema": {
        "type": "object",
        "properties": {
          "image": {
            "type": "string",
            "description": "Image file path or base64 encoded data"
          },
          "analysis_type": {
            "type": "string",
            "description": "Type of analysis: describe, detect_objects, extract_text, detect_faces, classify"
          },
          "model": {
            "type": "string",
            "description": "Model to use for analysis"
          },
          "detail_level": {
            "type": "string",
            "description": "Level of detail: low, medium, high"
          },
          "output_format": {
            "type": "string",
            "description": "Output format: json, text, structured"
          },
          "confidence_threshold": {
            "type": "number",
            "description": "Minimum confidence for detections"
          }
        },
        "required": [
          "image",
          "analysis_type",
          "detail_level",
          "output_format",
          "confidence_threshold"
        ]
      }
    },
    {
      "name": "image-generation",
      "description": "Generate images from text descriptions",
      "inputSchema": {
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Text description of the image to generate"
          },
          "model": {
            "type": "string",
            "description": "Model to use for generation"
          },
          "size": {
            "type": "string",
            "description": "Image size: 256x256, 512x512, 1024x1024"
          },
          "style": {
            "type": "string",
            "description": "Art style or aesthetic"
          },
          "negative_prompt": {
            "type": "string",
            "description": "What to avoid in the image"
          },
          "num_images": {
            "type": "integer",
            "description": "Number of images to generate"
          },
          "output_format": {
            "type": "string",
            "description": "Output format: url, base64, file"
          },
          "output_path": {
            "type": "string",
            "description": "Directory to save images"
          }
        },
        "required": [
          "prompt",
          "size",
          "num_images",
          "output_format",
          "output_path"
        ]
      }
    },
    {
      "name": "audio-processing",
      "description": "Process audio for transcription, analysis, and transformation",
      "inputSchema": {
        "type": "object",
        "properties": {
          "audio": {
            "type": "string",
            "description": "Audio file path or base64 encoded data"
          },
          "operation": {
            "type": "string",
            "description": "Operation: transcribe, analyze, enhance, convert"
          },
          "model": {
            "type": "string",
            "description": "Model to use for processing"
          },
          "language": {
            "type": "string",
            "description": "Language code for transcription"
          },
          "output_format": {
            "type": "string",
            "description": "Output format for conversion"
          },
          "enhance_options": {
            "type": "object",
            "description": "Enhancement options"
          }
        },
        "required": [
          "audio",
          "operation",
          "language"
        ]
      }
    },
    {
      "name": "video-processing",
      "description": "Process videos for analysis, extraction, and transformation",
      "inputSchema": {
        "type": "object",
        "properties": {
          "video": {
            "type": "string",
            "description": "Video file path or URL"
          },
          "operation": {
            "type": "string",
            "description": "Operation: analyze, extract_frames, extract_audio, summarize"
          },
          "model": {
            "type": "string",
            "description": "Model to use for analysis"
          },
          "frame_interval": {
            "type": "number",
            "description": "Seconds between frame extraction"
          },
          "start_time": {
            "type": "number",
            "description": "Start time in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time in seconds"
          },
          "output_path": {
            "type": "string",
            "description": "Output directory for extracted content"
          }
        },
        "required": [
          "video",
          "operation",
          "frame_interval",
          "start_time",
          "output_path"
        ]
      }
    },
    {
      "name": "mcp-server",
      "description": "Connect to MCP servers and execute their tools",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "Action to perform: connect, list_tools, execute_tool, disconnect"
          },
          "server_config": {
            "type": "object",
            "description": "Server configuration for connect action"
          },
          "server_name": {
            "type": "string",
            "description": "Name of the server"
          },
          "tool_name": {
            "type": "string",
            "description": "Name of the tool to execute"
          },
          "tool_params": {
            "type": "object",
            "description": "Parameters for tool execution"
          }
        },
        "required": [
          "action"
        ]
      }
    },
    {
      "name": "mcp-memory",
      "description": "Store and retrieve context for MCP server interactions",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "Action: store, retrieve, list, clear"
          },
          "key": {
            "type": "string",
            "description": "Memory key"
          },
          "value": {
            "type": "any",
            "description": "Value to store"
          },
          "namespace": {
            "type": "string",
            "description": "Memory namespace"
          },
          "ttl": {
            "type": "integer",
            "description": "Time to live in seconds (0 for permanent)"
          }
        },
        "required": [
          "action",
          "namespace",
          "ttl"
        ]
      }
    },
    {
      "name": "mcp-resource",
      "description": "Access resources from MCP servers",
      "inputSchema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "Action: list, read, subscribe, unsubscribe"
          },
          "server_name": {
            "type": "string",
            "description": "MCP server name"
          },
          "uri": {
            "type": "string",
            "description": "Resource URI"
          },
          "subscription_id": {
            "type": "string",
            "description": "Subscription ID for unsubscribe"
          }
        },
        "required": [
          "action",
          "server_name"
        ]
      }
    }
  ],
  "version": "1.0.0",
  "capabilities": {
    "tools": {
      "listChanged": true
    }
  }
}