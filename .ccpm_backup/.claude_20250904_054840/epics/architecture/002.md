---
name: Implement Runtime Dependency Resolution System for Dynamic Loop Expansion
status: active
created: 2025-08-19T00:18:04Z
updated: 2025-08-19T02:48:20Z
github: https://github.com/ContextLab/orchestrator/issues/211
imported: true
labels: enhancement, high-priority, architecture
---

# Implement Runtime Dependency Resolution System for Dynamic Loop Expansion

**GitHub Issue:** [#211](https://github.com/ContextLab/orchestrator/issues/211)
**Status:** OPEN
**Labels:** enhancement, high-priority, architecture

## Description

## Overview

This issue proposes a fundamental architectural improvement to how the orchestrator handles dependencies and loop expansion. Currently, loops are expanded at compile time, which fails when:
- Loop iterators depend on runtime values (e.g., `for_each: "{{ extract_sources.result }}"`)
- While loop iterations depend on runtime conditions
- Templates within loops reference results not yet available

This issue emerged from #159, where template rendering fails because dependencies aren't properly resolved at runtime.

## The Problem

### Current Architecture Flaws
1. **Compile-time loop expansion** assumes we know iteration counts before execution
2. **Static dependency checking** can't handle dynamically generated dependencies
3. **Template rendering** fails when referenced variables aren't available yet
4. **No progressive resolution** - items can't be resolved as dependencies become available

### Real-World Impact
```yaml
# This fails because select_text hasn't run when loop expands
- id: translate_text
  for_each: "{{ languages }}"
  steps:
    - id: translate
      parameters:
        prompt: "Translate: {{ select_text }}"  # ERROR: select_text undefined
  dependencies: [select_text]
```

## Proposed Solution: Runtime Dependency Resolution Engine

### Core Concept
Maintain a global execution state with all variables/results, and iteratively resolve dependencies as data becomes available, expanding loops only when their dependencies are satisfied.

### Architecture Components

#### 1. Pipeline Execution State
Centralized state tracking all variables, results, and template contexts:
```python
class PipelineExecutionState:
    global_context = {
        'variables': {},     # User and system variables
        'results': {},       # Task execution results  
        'loop_contexts': {}, # Active loop iterations
        'templates': {}      # Resolved template values
    }
    dependency_graph = DependencyGraph()
    unresolved_items = []  # Waiting for dependencies
```

#### 2. Dependency Resolution Engine
Iteratively resolves items as dependencies become available:
```python
class DependencyResolver:
    def resolve_all_pending(self):
        while progress_made:
            for item in unresolved_items:
                if dependencies_satisfied(item):
                    rendered = render_template(item)
                    update_global_state(rendered)
                    mark_resolved(item)
```

#### 3. Loop Runtime Expander
Expands loops when their dependencies are satisfied:
```python
class LoopExpander:
    def expand_loop(self, loop_task):
        # Resolve iterator expression at runtime
        items = resolve_expression(loop_task.for_each_expr)
        
        # Create tasks for each item with proper context
        for idx, item in enumerate(items):
            context = {'item': item, 'index': idx}
            tasks = create_tasks_from_templates(loop_task.steps, context)
```

### Execution Flow

1. **Initialize** with pipeline parameters
2. **Resolution Loop**:
   - Identify unresolved items (templates, loops, conditions)
   - Extract dependencies for each item
   - Resolve items whose dependencies are satisfied
   - Update global state with newly resolved values
   - Repeat until convergence or deadlock
3. **Task Execution**:
   - Execute tasks with fully resolved parameters
   - Register results in global state
   - Trigger new resolution passes
4. **Loop Expansion**:
   - Expand loops only when iterator is resolvable
   - While loops expand incrementally after each iteration

### Benefits

✅ **True runtime resolution** - Loops expand when ready, not at compile time
✅ **Progressive resolution** - Items resolve as soon as dependencies are available  
✅ **Flexible dependencies** - Any task can depend on any previous result
✅ **Clear error reporting** - System knows exactly what's blocking resolution
✅ **Incremental execution** - While loops can check conditions after each iteration

### Implementation Plan

#### Phase 1: Core Infrastructure (Week 1)
- [ ] Implement PipelineExecutionState class
- [ ] Create DependencyResolver with template parsing
- [ ] Build dependency extraction from templates
- [ ] Implement resolution iteration logic

#### Phase 2: Loop Support (Week 2)
- [ ] Implement LoopExpander for for_each loops
- [ ] Add while loop incremental expansion
- [ ] Handle nested loop contexts
- [ ] Test with existing pipelines

#### Phase 3: Integration (Week 3)
- [ ] Integrate with existing orchestrator
- [ ] Migrate template rendering to new system
- [ ] Update control flow compiler
- [ ] Comprehensive testing

#### Phase 4: Optimization (Week 4)
- [ ] Add caching for resolved templates
- [ ] Optimize dependency checking
- [ ] Enable parallel execution where possible
- [ ] Performance benchmarking

### Example Resolution Sequence

Given `control_flow_advanced.yaml`:
1. `analyze_text` executes (no dependencies)
2. `check_quality` executes (depends on analyze_text, now available)
3. `enhance_text` executes (depends on check_quality, now available)  
4. `select_text` executes (depends on enhance_text, now available)
5. `translate_text` loop NOW expands (depends on select_text, now available)
6. Loop tasks execute with `select_text` properly in context ✅

### Migration Strategy

1. **Compatibility mode** - Run new system alongside old
2. **Gradual migration** - Convert pipelines incrementally
3. **Validation** - Ensure identical results between systems
4. **Deprecation** - Phase out old system over 2-3 releases

### Success Criteria

- [ ] All existing pipelines work without modification
- [ ] Loops can depend on runtime-computed iterators
- [ ] Templates within loops can reference any previous result
- [ ] While loops work with runtime condition evaluation
- [ ] Clear error messages for unresolvable dependencies
- [ ] Performance comparable or better than current system

### Related Issues
- Fixes #159 (template rendering in for_each loops)
- Enables #184 (while loop improvements)
- Supports future dynamic pipeline features

### Discussion Points

1. Should we maintain backward compatibility or require migration?
2. How should we handle partial resolution failures?
3. Should resolution be synchronous or allow async/parallel?
4. What's the maximum iteration limit for resolution attempts?

This is a significant architectural change that will make the orchestrator much more robust and flexible. Looking forward to feedback and discussion on the approach.